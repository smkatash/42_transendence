{"ast":null,"code":"import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream } from \"engine.io-parser\";\nexport class WT extends Transport {\n  get name() {\n    return \"webtransport\";\n  }\n  doOpen() {\n    // @ts-ignore\n    if (typeof WebTransport !== \"function\") {\n      return;\n    }\n    // @ts-ignore\n    this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n    this.transport.closed.then(() => {\n      this.onClose();\n    }).catch(err => {\n      this.onError(\"webtransport error\", err);\n    });\n    // note: we could have used async/await, but that would require some additional polyfills\n    this.transport.ready.then(() => {\n      this.transport.createBidirectionalStream().then(stream => {\n        const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n        const reader = stream.readable.pipeThrough(decoderStream).getReader();\n        const encoderStream = createPacketEncoderStream();\n        encoderStream.readable.pipeTo(stream.writable);\n        this.writer = encoderStream.writable.getWriter();\n        const read = () => {\n          reader.read().then(({\n            done,\n            value\n          }) => {\n            if (done) {\n              return;\n            }\n            this.onPacket(value);\n            read();\n          }).catch(err => {});\n        };\n        read();\n        const packet = {\n          type: \"open\"\n        };\n        if (this.query.sid) {\n          packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n        }\n        this.writer.write(packet).then(() => this.onOpen());\n      });\n    });\n  }\n  write(packets) {\n    this.writable = false;\n    for (let i = 0; i < packets.length; i++) {\n      const packet = packets[i];\n      const lastPacket = i === packets.length - 1;\n      this.writer.write(packet).then(() => {\n        if (lastPacket) {\n          nextTick(() => {\n            this.writable = true;\n            this.emitReserved(\"drain\");\n          }, this.setTimeoutFn);\n        }\n      });\n    }\n  }\n  doClose() {\n    var _a;\n    (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}